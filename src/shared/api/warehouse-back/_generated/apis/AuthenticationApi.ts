/* tslint:disable */
/* eslint-disable */
/**
 * RAISER - Warehouse Management System API
 * REST API Ð´Ð»Ñ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹ ÑÐºÐ»Ð°Ð´ÑÐºÐ¾Ð³Ð¾ ÑƒÑ‡Ñ‘Ñ‚Ð° RAISER.  ## ÐÑƒÑ‚ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ñ  API Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚ Ð´Ð²Ð° Ð¼ÐµÑ‚Ð¾Ð´Ð° Ð°ÑƒÑ‚ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ð¸:  ### ðŸ” ÐœÐµÑ‚Ð¾Ð´ 1: JWT Bearer Token (Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÑ‚ÑÑ) 1. POST /api/auth/login - Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ access token Ð¸ refresh token 2. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ access token Ð´Ð»Ñ Ð²ÑÐµÑ… Ð·Ð°Ñ‰Ð¸Ñ‰Ñ‘Ð½Ð½Ñ‹Ñ… endpoints 3. POST /api/auth/refresh - Ð¾Ð±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ access token (ÐºÐ¾Ð³Ð´Ð° Ð¸ÑÑ‚ÐµÑ‡Ñ‘Ñ‚)  **ÐŸÑ€ÐµÐ¸Ð¼ÑƒÑ‰ÐµÑÑ‚Ð²Ð°:** - âœ… Stateless (Ð½Ðµ Ð½ÑƒÐ¶Ð½Ð° session Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€Ðµ) - âœ… Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð´Ð»Ñ production - âœ… ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° refresh tokens - âœ… ÐœÐ°ÑÑˆÑ‚Ð°Ð±Ð¸Ñ€ÑƒÐµÑ‚ÑÑ Ð³Ð¾Ñ€Ð¸Ð·Ð¾Ð½Ñ‚Ð°Ð»ÑŒÐ½Ð¾  ### ðŸ”“ ÐœÐµÑ‚Ð¾Ð´ 2: HTTP Basic Authentication (Ñ‚Ð¾Ð»ÑŒÐºÐ¾ dev/staging!) ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐ¹Ñ‚Ðµ username Ð¸ password Ð² ÐºÐ°Ð¶Ð´Ð¾Ð¼ request.  **Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð´Ð»Ñ:** - âœ… Ð‘Ñ‹ÑÑ‚Ñ€Ð¾Ð³Ð¾ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð² Swagger UI - âœ… Dev/Staging Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ð¹ - âŒ ÐÐ• Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð² production Ð±ÐµÐ· HTTPS!  ### ÐÐ²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ñ (Permission-based RBAC) Ð¡Ð¸ÑÑ‚ÐµÐ¼Ð° Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ Ð¿Ñ€Ð°Ð²Ð° Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð° (permissions): - Permissions (Ð¿Ñ€Ð°Ð²Ð°): USER_VIEW, USER_CREATE, USER_EDIT, INVENTORY_WRITE, etc. - Roles (Ñ€Ð¾Ð»Ð¸): ADMIN, WR_KEEPER, USER - User-level overrides: permissionsAdd, permissionsRemove - Ð¤Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð¿Ñ€Ð°Ð²Ð°: (role_permissions âˆª permissionsAdd) âˆ’ permissionsRemove  ## Ð¢Ð¸Ð¿Ð¸Ñ‡Ð½Ñ‹Ð¹ workflow:  **Ð¡ JWT:** 1. POST /api/auth/login â†’ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ accessToken 2. ÐÐ°Ð¶Ð°Ñ‚ÑŒ \"Authorize\" â†’ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ \"Bearer Authentication\" 3. Ð’ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ Ñ‚Ð¾ÐºÐµÐ½ â†’ Authorize 4. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ API endpoints  **Ð¡ Basic Auth (Ñ‚Ð¾Ð»ÑŒÐºÐ¾ dev/staging):** 1. ÐÐ°Ð¶Ð°Ñ‚ÑŒ \"Authorize\" â†’ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ \"Basic Authentication\" 2. Ð’Ð²ÐµÑÑ‚Ð¸ username Ð¸ password â†’ Authorize 3. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ API endpoints (credentials Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÑŽÑ‚ÑÑ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: dev@raiser.uz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { SWRConfiguration } from "swr"
import { SWRMutationConfiguration } from "swr/mutation"
import * as runtime from "../runtime"

import * as swrs from "./AuthenticationApiSwr"

import {
  LoginRequest,
  LoginRequestToJSON,
  RefreshTokenRequest,
  RefreshTokenRequestToJSON,
  TokenResponse,
  TokenResponseFromJSON,
} from "../models"

export interface LoginOperationRequest {
  loginRequest: LoginRequest
}

export interface LogoutRequest {
  refreshTokenRequest: RefreshTokenRequest
}

export interface RefreshRequest {
  refreshTokenRequest: RefreshTokenRequest
}

/**
 *
 */
export class AuthenticationApi extends runtime.BaseAPI {
  /**
   * Check if user is authenticated (requires valid JWT token)
   * Check authentication
   */
  protected authenticateRequestOpts = (): runtime.RequestOpts => {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    return {
      path: `/api/auth/authenticate`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }
  }

  /**
   * Check if user is authenticated (requires valid JWT token)
   * Check authentication
   */
  protected authenticateFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Check if user is authenticated (requires valid JWT token)
   * Check authentication
   */
  protected authenticateRaw = async (initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> => {
    const context = this.authenticateRequestOpts()
    return this.authenticateFetch(context, initOverrides)
  }

  /**
   * Check if user is authenticated (requires valid JWT token)
   * Check authentication
   */
  authenticate = async (initOverrides?: RequestInit): Promise<void> => {
    await this.authenticateRaw(initOverrides)
  }

  /**
   * Check if user is authenticated (requires valid JWT token)
   * Check authentication
   */
  useAuthenticate = (config?: SWRConfiguration<void>) => {
    return swrs.useAuthenticate(
      () => this.authenticateRequestOpts(),
      (context: runtime.RequestOpts) => this.swrFetch(this.authenticateFetch(context)),

      config,
    )
  }

  /**
   * Check if user is authenticated (requires valid JWT token)
   * Check authentication
   */
  useAuthenticateImmutable = (config?: SWRConfiguration<void>) => {
    return swrs.useAuthenticateImmutable(
      () => this.authenticateRequestOpts(),
      (context: runtime.RequestOpts) => this.swrFetch(this.authenticateFetch(context)),

      config,
    )
  }

  /**
   * Check if user is authenticated (requires valid JWT token)
   * Check authentication
   */
  useAuthenticateMutation = (config?: SWRMutationConfiguration<void, any, string, never, void>) => {
    return swrs.useAuthenticateMutation(
      () => this.authenticateRequestOpts(),
      (context: runtime.RequestOpts) => this.swrFetch(this.authenticateFetch(context)),

      config,
    )
  }

  /**
   * Authenticate user with username and password, returns JWT tokens
   * Login
   */
  protected loginRequestOpts = (requestParameters: LoginOperationRequest): runtime.RequestOpts => {
    if (requestParameters.loginRequest === null || requestParameters.loginRequest === undefined) {
      throw new runtime.RequiredError(
        "loginRequest",
        "Required parameter requestParameters.loginRequest was null or undefined when calling login.",
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    return {
      path: `/api/auth/login`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: LoginRequestToJSON(requestParameters.loginRequest),
    }
  }

  /**
   * Authenticate user with username and password, returns JWT tokens
   * Login
   */
  protected loginFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<TokenResponse>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.JSONApiResponse(response, (jsonValue) => TokenResponseFromJSON(jsonValue))
  }

  /**
   * Authenticate user with username and password, returns JWT tokens
   * Login
   */
  protected loginRaw = async (
    requestParameters: LoginOperationRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<TokenResponse>> => {
    const context = this.loginRequestOpts(requestParameters)
    return this.loginFetch(context, initOverrides)
  }

  /**
   * Authenticate user with username and password, returns JWT tokens
   * Login
   */
  login = async (loginRequest: LoginRequest, initOverrides?: RequestInit): Promise<TokenResponse> => {
    const response = await this.loginRaw({ loginRequest: loginRequest }, initOverrides)
    return await response.value()
  }

  /**
   * Authenticate user with username and password, returns JWT tokens
   * Login
   */
  useLogin = (loginRequest: LoginRequest, config?: SWRConfiguration<TokenResponse>) => {
    return swrs.useLogin(
      (loginRequest: LoginRequest) => this.loginRequestOpts({ loginRequest: loginRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.loginFetch(context)),
      loginRequest,
      config,
    )
  }

  /**
   * Authenticate user with username and password, returns JWT tokens
   * Login
   */
  useLoginImmutable = (loginRequest: LoginRequest, config?: SWRConfiguration<TokenResponse>) => {
    return swrs.useLoginImmutable(
      (loginRequest: LoginRequest) => this.loginRequestOpts({ loginRequest: loginRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.loginFetch(context)),
      loginRequest,
      config,
    )
  }

  /**
   * Authenticate user with username and password, returns JWT tokens
   * Login
   */
  useLoginMutation = (
    loginRequest: LoginRequest,
    config?: SWRMutationConfiguration<TokenResponse, any, string, never, TokenResponse>,
  ) => {
    return swrs.useLoginMutation(
      (loginRequest: LoginRequest) => this.loginRequestOpts({ loginRequest: loginRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.loginFetch(context)),
      loginRequest,
      config,
    )
  }

  /**
   * Invalidate refresh token (access token remains valid until expiration)
   * Logout
   */
  protected logoutRequestOpts = (requestParameters: LogoutRequest): runtime.RequestOpts => {
    if (requestParameters.refreshTokenRequest === null || requestParameters.refreshTokenRequest === undefined) {
      throw new runtime.RequiredError(
        "refreshTokenRequest",
        "Required parameter requestParameters.refreshTokenRequest was null or undefined when calling logout.",
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    return {
      path: `/api/auth/logout`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RefreshTokenRequestToJSON(requestParameters.refreshTokenRequest),
    }
  }

  /**
   * Invalidate refresh token (access token remains valid until expiration)
   * Logout
   */
  protected logoutFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Invalidate refresh token (access token remains valid until expiration)
   * Logout
   */
  protected logoutRaw = async (
    requestParameters: LogoutRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> => {
    const context = this.logoutRequestOpts(requestParameters)
    return this.logoutFetch(context, initOverrides)
  }

  /**
   * Invalidate refresh token (access token remains valid until expiration)
   * Logout
   */
  logout = async (refreshTokenRequest: RefreshTokenRequest, initOverrides?: RequestInit): Promise<void> => {
    await this.logoutRaw({ refreshTokenRequest: refreshTokenRequest }, initOverrides)
  }

  /**
   * Invalidate refresh token (access token remains valid until expiration)
   * Logout
   */
  useLogout = (refreshTokenRequest: RefreshTokenRequest, config?: SWRConfiguration<void>) => {
    return swrs.useLogout(
      (refreshTokenRequest: RefreshTokenRequest) =>
        this.logoutRequestOpts({ refreshTokenRequest: refreshTokenRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.logoutFetch(context)),
      refreshTokenRequest,
      config,
    )
  }

  /**
   * Invalidate refresh token (access token remains valid until expiration)
   * Logout
   */
  useLogoutImmutable = (refreshTokenRequest: RefreshTokenRequest, config?: SWRConfiguration<void>) => {
    return swrs.useLogoutImmutable(
      (refreshTokenRequest: RefreshTokenRequest) =>
        this.logoutRequestOpts({ refreshTokenRequest: refreshTokenRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.logoutFetch(context)),
      refreshTokenRequest,
      config,
    )
  }

  /**
   * Invalidate refresh token (access token remains valid until expiration)
   * Logout
   */
  useLogoutMutation = (
    refreshTokenRequest: RefreshTokenRequest,
    config?: SWRMutationConfiguration<void, any, string, never, void>,
  ) => {
    return swrs.useLogoutMutation(
      (refreshTokenRequest: RefreshTokenRequest) =>
        this.logoutRequestOpts({ refreshTokenRequest: refreshTokenRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.logoutFetch(context)),
      refreshTokenRequest,
      config,
    )
  }

  /**
   * Exchange refresh token for new access token
   * Refresh token
   */
  protected refreshRequestOpts = (requestParameters: RefreshRequest): runtime.RequestOpts => {
    if (requestParameters.refreshTokenRequest === null || requestParameters.refreshTokenRequest === undefined) {
      throw new runtime.RequiredError(
        "refreshTokenRequest",
        "Required parameter requestParameters.refreshTokenRequest was null or undefined when calling refresh.",
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    return {
      path: `/api/auth/refresh`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RefreshTokenRequestToJSON(requestParameters.refreshTokenRequest),
    }
  }

  /**
   * Exchange refresh token for new access token
   * Refresh token
   */
  protected refreshFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<TokenResponse>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.JSONApiResponse(response, (jsonValue) => TokenResponseFromJSON(jsonValue))
  }

  /**
   * Exchange refresh token for new access token
   * Refresh token
   */
  protected refreshRaw = async (
    requestParameters: RefreshRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<TokenResponse>> => {
    const context = this.refreshRequestOpts(requestParameters)
    return this.refreshFetch(context, initOverrides)
  }

  /**
   * Exchange refresh token for new access token
   * Refresh token
   */
  refresh = async (refreshTokenRequest: RefreshTokenRequest, initOverrides?: RequestInit): Promise<TokenResponse> => {
    const response = await this.refreshRaw({ refreshTokenRequest: refreshTokenRequest }, initOverrides)
    return await response.value()
  }

  /**
   * Exchange refresh token for new access token
   * Refresh token
   */
  useRefresh = (refreshTokenRequest: RefreshTokenRequest, config?: SWRConfiguration<TokenResponse>) => {
    return swrs.useRefresh(
      (refreshTokenRequest: RefreshTokenRequest) =>
        this.refreshRequestOpts({ refreshTokenRequest: refreshTokenRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.refreshFetch(context)),
      refreshTokenRequest,
      config,
    )
  }

  /**
   * Exchange refresh token for new access token
   * Refresh token
   */
  useRefreshImmutable = (refreshTokenRequest: RefreshTokenRequest, config?: SWRConfiguration<TokenResponse>) => {
    return swrs.useRefreshImmutable(
      (refreshTokenRequest: RefreshTokenRequest) =>
        this.refreshRequestOpts({ refreshTokenRequest: refreshTokenRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.refreshFetch(context)),
      refreshTokenRequest,
      config,
    )
  }

  /**
   * Exchange refresh token for new access token
   * Refresh token
   */
  useRefreshMutation = (
    refreshTokenRequest: RefreshTokenRequest,
    config?: SWRMutationConfiguration<TokenResponse, any, string, never, TokenResponse>,
  ) => {
    return swrs.useRefreshMutation(
      (refreshTokenRequest: RefreshTokenRequest) =>
        this.refreshRequestOpts({ refreshTokenRequest: refreshTokenRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.refreshFetch(context)),
      refreshTokenRequest,
      config,
    )
  }
}
