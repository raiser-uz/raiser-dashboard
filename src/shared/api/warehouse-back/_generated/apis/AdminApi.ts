/* tslint:disable */
/* eslint-disable */
/**
 * RAISER - Warehouse Management System API
 * REST API Ð´Ð»Ñ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹ ÑÐºÐ»Ð°Ð´ÑÐºÐ¾Ð³Ð¾ ÑƒÑ‡Ñ‘Ñ‚Ð° RAISER.  ## ÐÑƒÑ‚ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ñ  API Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚ Ð´Ð²Ð° Ð¼ÐµÑ‚Ð¾Ð´Ð° Ð°ÑƒÑ‚ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ð¸:  ### ðŸ” ÐœÐµÑ‚Ð¾Ð´ 1: JWT Bearer Token (Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÑ‚ÑÑ) 1. POST /api/auth/login - Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ access token Ð¸ refresh token 2. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ access token Ð´Ð»Ñ Ð²ÑÐµÑ… Ð·Ð°Ñ‰Ð¸Ñ‰Ñ‘Ð½Ð½Ñ‹Ñ… endpoints 3. POST /api/auth/refresh - Ð¾Ð±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ access token (ÐºÐ¾Ð³Ð´Ð° Ð¸ÑÑ‚ÐµÑ‡Ñ‘Ñ‚)  **ÐŸÑ€ÐµÐ¸Ð¼ÑƒÑ‰ÐµÑÑ‚Ð²Ð°:** - âœ… Stateless (Ð½Ðµ Ð½ÑƒÐ¶Ð½Ð° session Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€Ðµ) - âœ… Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð´Ð»Ñ production - âœ… ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° refresh tokens - âœ… ÐœÐ°ÑÑˆÑ‚Ð°Ð±Ð¸Ñ€ÑƒÐµÑ‚ÑÑ Ð³Ð¾Ñ€Ð¸Ð·Ð¾Ð½Ñ‚Ð°Ð»ÑŒÐ½Ð¾  ### ðŸ”“ ÐœÐµÑ‚Ð¾Ð´ 2: HTTP Basic Authentication (Ñ‚Ð¾Ð»ÑŒÐºÐ¾ dev/staging!) ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐ¹Ñ‚Ðµ username Ð¸ password Ð² ÐºÐ°Ð¶Ð´Ð¾Ð¼ request.  **Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð´Ð»Ñ:** - âœ… Ð‘Ñ‹ÑÑ‚Ñ€Ð¾Ð³Ð¾ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð² Swagger UI - âœ… Dev/Staging Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ð¹ - âŒ ÐÐ• Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð² production Ð±ÐµÐ· HTTPS!  ### ÐÐ²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ñ (Permission-based RBAC) Ð¡Ð¸ÑÑ‚ÐµÐ¼Ð° Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ Ð¿Ñ€Ð°Ð²Ð° Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð° (permissions): - Permissions (Ð¿Ñ€Ð°Ð²Ð°): USER_VIEW, USER_CREATE, USER_EDIT, INVENTORY_WRITE, etc. - Roles (Ñ€Ð¾Ð»Ð¸): ADMIN, WR_KEEPER, USER - User-level overrides: permissionsAdd, permissionsRemove - Ð¤Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð¿Ñ€Ð°Ð²Ð°: (role_permissions âˆª permissionsAdd) âˆ’ permissionsRemove  ## Ð¢Ð¸Ð¿Ð¸Ñ‡Ð½Ñ‹Ð¹ workflow:  **Ð¡ JWT:** 1. POST /api/auth/login â†’ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ accessToken 2. ÐÐ°Ð¶Ð°Ñ‚ÑŒ \"Authorize\" â†’ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ \"Bearer Authentication\" 3. Ð’ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ Ñ‚Ð¾ÐºÐµÐ½ â†’ Authorize 4. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ API endpoints  **Ð¡ Basic Auth (Ñ‚Ð¾Ð»ÑŒÐºÐ¾ dev/staging):** 1. ÐÐ°Ð¶Ð°Ñ‚ÑŒ \"Authorize\" â†’ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ \"Basic Authentication\" 2. Ð’Ð²ÐµÑÑ‚Ð¸ username Ð¸ password â†’ Authorize 3. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ API endpoints (credentials Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÑŽÑ‚ÑÑ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: dev@raiser.uz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { SWRConfiguration } from "swr"
import { SWRMutationConfiguration } from "swr/mutation"
import * as runtime from "../runtime"

import * as swrs from "./AdminApiSwr"

import {
  ChangePasswordRequest,
  ChangePasswordRequestToJSON,
  CreateUserRequest,
  CreateUserRequestToJSON,
  Page,
  PageFromJSON,
  Pageable,
  RoleDTO,
  RoleDTOFromJSON,
  UpdateUserRequest,
  UpdateUserRequestToJSON,
  UserDTO,
  UserDTOFromJSON,
} from "../models"

export interface ChangeUserPasswordRequest {
  id: string
  changePasswordRequest: ChangePasswordRequest
}

export interface CreateUserOperationRequest {
  createUserRequest: CreateUserRequest
}

export interface DeleteUserRequest {
  id: string
}

export interface GetAllUsersRequest {
  pageable: Pageable
}

export interface GetRoleByIdRequest {
  id: string
}

export interface GetUserByIdRequest {
  id: string
}

export interface GetUserPermissionsRequest {
  id: string
}

export interface SearchUsersRequest {
  pageable: Pageable
  q?: string
}

export interface ToggleUserLockRequest {
  id: string
  requestBody: { [key: string]: boolean }
}

export interface ToggleUserStatusRequest {
  id: string
  requestBody: { [key: string]: boolean }
}

export interface UpdateUserOperationRequest {
  id: string
  updateUserRequest: UpdateUserRequest
}

/**
 *
 */
export class AdminApi extends runtime.BaseAPI {
  /**
   * Change user password without requiring old password (admin mode)
   * Change user password (admin)
   */
  protected changeUserPasswordRequestOpts = (requestParameters: ChangeUserPasswordRequest): runtime.RequestOpts => {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling changeUserPassword.",
      )
    }

    if (requestParameters.changePasswordRequest === null || requestParameters.changePasswordRequest === undefined) {
      throw new runtime.RequiredError(
        "changePasswordRequest",
        "Required parameter requestParameters.changePasswordRequest was null or undefined when calling changeUserPassword.",
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    return {
      path: `/api/admin/users/{id}/change-password`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(requestParameters.id)),
      ),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ChangePasswordRequestToJSON(requestParameters.changePasswordRequest),
    }
  }

  /**
   * Change user password without requiring old password (admin mode)
   * Change user password (admin)
   */
  protected changeUserPasswordFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Change user password without requiring old password (admin mode)
   * Change user password (admin)
   */
  protected changeUserPasswordRaw = async (
    requestParameters: ChangeUserPasswordRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> => {
    const context = this.changeUserPasswordRequestOpts(requestParameters)
    return this.changeUserPasswordFetch(context, initOverrides)
  }

  /**
   * Change user password without requiring old password (admin mode)
   * Change user password (admin)
   */
  changeUserPassword = async (
    id: string,
    changePasswordRequest: ChangePasswordRequest,
    initOverrides?: RequestInit,
  ): Promise<void> => {
    await this.changeUserPasswordRaw({ id: id, changePasswordRequest: changePasswordRequest }, initOverrides)
  }

  /**
   * Change user password without requiring old password (admin mode)
   * Change user password (admin)
   */
  useChangeUserPassword = (
    id: string,
    changePasswordRequest: ChangePasswordRequest,
    config?: SWRConfiguration<void>,
  ) => {
    return swrs.useChangeUserPassword(
      (id: string, changePasswordRequest: ChangePasswordRequest) =>
        this.changeUserPasswordRequestOpts({ id: id, changePasswordRequest: changePasswordRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.changeUserPasswordFetch(context)),
      id,
      changePasswordRequest,
      config,
    )
  }

  /**
   * Change user password without requiring old password (admin mode)
   * Change user password (admin)
   */
  useChangeUserPasswordImmutable = (
    id: string,
    changePasswordRequest: ChangePasswordRequest,
    config?: SWRConfiguration<void>,
  ) => {
    return swrs.useChangeUserPasswordImmutable(
      (id: string, changePasswordRequest: ChangePasswordRequest) =>
        this.changeUserPasswordRequestOpts({ id: id, changePasswordRequest: changePasswordRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.changeUserPasswordFetch(context)),
      id,
      changePasswordRequest,
      config,
    )
  }

  /**
   * Change user password without requiring old password (admin mode)
   * Change user password (admin)
   */
  useChangeUserPasswordMutation = (
    id: string,
    changePasswordRequest: ChangePasswordRequest,
    config?: SWRMutationConfiguration<void, any, string, never, void>,
  ) => {
    return swrs.useChangeUserPasswordMutation(
      (id: string, changePasswordRequest: ChangePasswordRequest) =>
        this.changeUserPasswordRequestOpts({ id: id, changePasswordRequest: changePasswordRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.changeUserPasswordFetch(context)),
      id,
      changePasswordRequest,
      config,
    )
  }

  /**
   * Create new user with roles
   * Create user
   */
  protected createUserRequestOpts = (requestParameters: CreateUserOperationRequest): runtime.RequestOpts => {
    if (requestParameters.createUserRequest === null || requestParameters.createUserRequest === undefined) {
      throw new runtime.RequiredError(
        "createUserRequest",
        "Required parameter requestParameters.createUserRequest was null or undefined when calling createUser.",
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    return {
      path: `/api/admin/users`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateUserRequestToJSON(requestParameters.createUserRequest),
    }
  }

  /**
   * Create new user with roles
   * Create user
   */
  protected createUserFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UserDTO>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.JSONApiResponse(response, (jsonValue) => UserDTOFromJSON(jsonValue))
  }

  /**
   * Create new user with roles
   * Create user
   */
  protected createUserRaw = async (
    requestParameters: CreateUserOperationRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UserDTO>> => {
    const context = this.createUserRequestOpts(requestParameters)
    return this.createUserFetch(context, initOverrides)
  }

  /**
   * Create new user with roles
   * Create user
   */
  createUser = async (createUserRequest: CreateUserRequest, initOverrides?: RequestInit): Promise<UserDTO> => {
    const response = await this.createUserRaw({ createUserRequest: createUserRequest }, initOverrides)
    return await response.value()
  }

  /**
   * Create new user with roles
   * Create user
   */
  useCreateUser = (createUserRequest: CreateUserRequest, config?: SWRConfiguration<UserDTO>) => {
    return swrs.useCreateUser(
      (createUserRequest: CreateUserRequest) => this.createUserRequestOpts({ createUserRequest: createUserRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.createUserFetch(context)),
      createUserRequest,
      config,
    )
  }

  /**
   * Create new user with roles
   * Create user
   */
  useCreateUserImmutable = (createUserRequest: CreateUserRequest, config?: SWRConfiguration<UserDTO>) => {
    return swrs.useCreateUserImmutable(
      (createUserRequest: CreateUserRequest) => this.createUserRequestOpts({ createUserRequest: createUserRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.createUserFetch(context)),
      createUserRequest,
      config,
    )
  }

  /**
   * Create new user with roles
   * Create user
   */
  useCreateUserMutation = (
    createUserRequest: CreateUserRequest,
    config?: SWRMutationConfiguration<UserDTO, any, string, never, UserDTO>,
  ) => {
    return swrs.useCreateUserMutation(
      (createUserRequest: CreateUserRequest) => this.createUserRequestOpts({ createUserRequest: createUserRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.createUserFetch(context)),
      createUserRequest,
      config,
    )
  }

  /**
   * Delete user by ID (physical deletion)
   * Delete user
   */
  protected deleteUserRequestOpts = (requestParameters: DeleteUserRequest): runtime.RequestOpts => {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling deleteUser.",
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    return {
      path: `/api/admin/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters,
    }
  }

  /**
   * Delete user by ID (physical deletion)
   * Delete user
   */
  protected deleteUserFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Delete user by ID (physical deletion)
   * Delete user
   */
  protected deleteUserRaw = async (
    requestParameters: DeleteUserRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> => {
    const context = this.deleteUserRequestOpts(requestParameters)
    return this.deleteUserFetch(context, initOverrides)
  }

  /**
   * Delete user by ID (physical deletion)
   * Delete user
   */
  deleteUser = async (id: string, initOverrides?: RequestInit): Promise<void> => {
    await this.deleteUserRaw({ id: id }, initOverrides)
  }

  /**
   * Delete user by ID (physical deletion)
   * Delete user
   */
  useDeleteUser = (id: string, config?: SWRConfiguration<void>) => {
    return swrs.useDeleteUser(
      (id: string) => this.deleteUserRequestOpts({ id: id }),
      (context: runtime.RequestOpts) => this.swrFetch(this.deleteUserFetch(context)),
      id,
      config,
    )
  }

  /**
   * Delete user by ID (physical deletion)
   * Delete user
   */
  useDeleteUserImmutable = (id: string, config?: SWRConfiguration<void>) => {
    return swrs.useDeleteUserImmutable(
      (id: string) => this.deleteUserRequestOpts({ id: id }),
      (context: runtime.RequestOpts) => this.swrFetch(this.deleteUserFetch(context)),
      id,
      config,
    )
  }

  /**
   * Delete user by ID (physical deletion)
   * Delete user
   */
  useDeleteUserMutation = (id: string, config?: SWRMutationConfiguration<void, any, string, never, void>) => {
    return swrs.useDeleteUserMutation(
      (id: string) => this.deleteUserRequestOpts({ id: id }),
      (context: runtime.RequestOpts) => this.swrFetch(this.deleteUserFetch(context)),
      id,
      config,
    )
  }

  /**
   * Get list of all permissions (sorted by module, code)
   * Get all permissions
   */
  protected getAllPermissionsRequestOpts = (): runtime.RequestOpts => {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    return {
      path: `/api/admin/permissions`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }
  }

  /**
   * Get list of all permissions (sorted by module, code)
   * Get all permissions
   */
  protected getAllPermissionsFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Get list of all permissions (sorted by module, code)
   * Get all permissions
   */
  protected getAllPermissionsRaw = async (initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> => {
    const context = this.getAllPermissionsRequestOpts()
    return this.getAllPermissionsFetch(context, initOverrides)
  }

  /**
   * Get list of all permissions (sorted by module, code)
   * Get all permissions
   */
  getAllPermissions = async (initOverrides?: RequestInit): Promise<void> => {
    await this.getAllPermissionsRaw(initOverrides)
  }

  /**
   * Get list of all permissions (sorted by module, code)
   * Get all permissions
   */
  useGetAllPermissions = (config?: SWRConfiguration<void>) => {
    return swrs.useGetAllPermissions(
      () => this.getAllPermissionsRequestOpts(),
      (context: runtime.RequestOpts) => this.swrFetch(this.getAllPermissionsFetch(context)),

      config,
    )
  }

  /**
   * Get list of all permissions (sorted by module, code)
   * Get all permissions
   */
  useGetAllPermissionsImmutable = (config?: SWRConfiguration<void>) => {
    return swrs.useGetAllPermissionsImmutable(
      () => this.getAllPermissionsRequestOpts(),
      (context: runtime.RequestOpts) => this.swrFetch(this.getAllPermissionsFetch(context)),

      config,
    )
  }

  /**
   * Get list of all permissions (sorted by module, code)
   * Get all permissions
   */
  useGetAllPermissionsMutation = (config?: SWRMutationConfiguration<void, any, string, never, void>) => {
    return swrs.useGetAllPermissionsMutation(
      () => this.getAllPermissionsRequestOpts(),
      (context: runtime.RequestOpts) => this.swrFetch(this.getAllPermissionsFetch(context)),

      config,
    )
  }

  /**
   * Get list of all roles with their permissions
   * Get all roles
   */
  protected getAllRolesRequestOpts = (): runtime.RequestOpts => {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    return {
      path: `/api/admin/roles`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }
  }

  /**
   * Get list of all roles with their permissions
   * Get all roles
   */
  protected getAllRolesFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Get list of all roles with their permissions
   * Get all roles
   */
  protected getAllRolesRaw = async (initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> => {
    const context = this.getAllRolesRequestOpts()
    return this.getAllRolesFetch(context, initOverrides)
  }

  /**
   * Get list of all roles with their permissions
   * Get all roles
   */
  getAllRoles = async (initOverrides?: RequestInit): Promise<void> => {
    await this.getAllRolesRaw(initOverrides)
  }

  /**
   * Get list of all roles with their permissions
   * Get all roles
   */
  useGetAllRoles = (config?: SWRConfiguration<void>) => {
    return swrs.useGetAllRoles(
      () => this.getAllRolesRequestOpts(),
      (context: runtime.RequestOpts) => this.swrFetch(this.getAllRolesFetch(context)),

      config,
    )
  }

  /**
   * Get list of all roles with their permissions
   * Get all roles
   */
  useGetAllRolesImmutable = (config?: SWRConfiguration<void>) => {
    return swrs.useGetAllRolesImmutable(
      () => this.getAllRolesRequestOpts(),
      (context: runtime.RequestOpts) => this.swrFetch(this.getAllRolesFetch(context)),

      config,
    )
  }

  /**
   * Get list of all roles with their permissions
   * Get all roles
   */
  useGetAllRolesMutation = (config?: SWRMutationConfiguration<void, any, string, never, void>) => {
    return swrs.useGetAllRolesMutation(
      () => this.getAllRolesRequestOpts(),
      (context: runtime.RequestOpts) => this.swrFetch(this.getAllRolesFetch(context)),

      config,
    )
  }

  /**
   * Get paginated list of all users (without roles/permissions for performance)
   * Get all users
   */
  protected getAllUsersRequestOpts = (requestParameters: GetAllUsersRequest): runtime.RequestOpts => {
    if (requestParameters.pageable === null || requestParameters.pageable === undefined) {
      throw new runtime.RequiredError(
        "pageable",
        "Required parameter requestParameters.pageable was null or undefined when calling getAllUsers.",
      )
    }

    const queryParameters: any = {}

    if (requestParameters.pageable !== undefined) {
      queryParameters["pageable"] = requestParameters.pageable
    }

    const headerParameters: runtime.HTTPHeaders = {}

    return {
      path: `/api/admin/users`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }
  }

  /**
   * Get paginated list of all users (without roles/permissions for performance)
   * Get all users
   */
  protected getAllUsersFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Page>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.JSONApiResponse(response, (jsonValue) => PageFromJSON(jsonValue))
  }

  /**
   * Get paginated list of all users (without roles/permissions for performance)
   * Get all users
   */
  protected getAllUsersRaw = async (
    requestParameters: GetAllUsersRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Page>> => {
    const context = this.getAllUsersRequestOpts(requestParameters)
    return this.getAllUsersFetch(context, initOverrides)
  }

  /**
   * Get paginated list of all users (without roles/permissions for performance)
   * Get all users
   */
  getAllUsers = async (pageable: Pageable, initOverrides?: RequestInit): Promise<Page> => {
    const response = await this.getAllUsersRaw({ pageable: pageable }, initOverrides)
    return await response.value()
  }

  /**
   * Get paginated list of all users (without roles/permissions for performance)
   * Get all users
   */
  useGetAllUsers = (pageable: Pageable, config?: SWRConfiguration<Page>) => {
    return swrs.useGetAllUsers(
      (pageable: Pageable) => this.getAllUsersRequestOpts({ pageable: pageable }),
      (context: runtime.RequestOpts) => this.swrFetch(this.getAllUsersFetch(context)),
      pageable,
      config,
    )
  }

  /**
   * Get paginated list of all users (without roles/permissions for performance)
   * Get all users
   */
  useGetAllUsersImmutable = (pageable: Pageable, config?: SWRConfiguration<Page>) => {
    return swrs.useGetAllUsersImmutable(
      (pageable: Pageable) => this.getAllUsersRequestOpts({ pageable: pageable }),
      (context: runtime.RequestOpts) => this.swrFetch(this.getAllUsersFetch(context)),
      pageable,
      config,
    )
  }

  /**
   * Get paginated list of all users (without roles/permissions for performance)
   * Get all users
   */
  useGetAllUsersMutation = (pageable: Pageable, config?: SWRMutationConfiguration<Page, any, string, never, Page>) => {
    return swrs.useGetAllUsersMutation(
      (pageable: Pageable) => this.getAllUsersRequestOpts({ pageable: pageable }),
      (context: runtime.RequestOpts) => this.swrFetch(this.getAllUsersFetch(context)),
      pageable,
      config,
    )
  }

  /**
   * Get role details by ID (with permissions)
   * Get role by ID
   */
  protected getRoleByIdRequestOpts = (requestParameters: GetRoleByIdRequest): runtime.RequestOpts => {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling getRoleById.",
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    return {
      path: `/api/admin/roles/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }
  }

  /**
   * Get role details by ID (with permissions)
   * Get role by ID
   */
  protected getRoleByIdFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<RoleDTO>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.JSONApiResponse(response, (jsonValue) => RoleDTOFromJSON(jsonValue))
  }

  /**
   * Get role details by ID (with permissions)
   * Get role by ID
   */
  protected getRoleByIdRaw = async (
    requestParameters: GetRoleByIdRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<RoleDTO>> => {
    const context = this.getRoleByIdRequestOpts(requestParameters)
    return this.getRoleByIdFetch(context, initOverrides)
  }

  /**
   * Get role details by ID (with permissions)
   * Get role by ID
   */
  getRoleById = async (id: string, initOverrides?: RequestInit): Promise<RoleDTO> => {
    const response = await this.getRoleByIdRaw({ id: id }, initOverrides)
    return await response.value()
  }

  /**
   * Get role details by ID (with permissions)
   * Get role by ID
   */
  useGetRoleById = (id: string, config?: SWRConfiguration<RoleDTO>) => {
    return swrs.useGetRoleById(
      (id: string) => this.getRoleByIdRequestOpts({ id: id }),
      (context: runtime.RequestOpts) => this.swrFetch(this.getRoleByIdFetch(context)),
      id,
      config,
    )
  }

  /**
   * Get role details by ID (with permissions)
   * Get role by ID
   */
  useGetRoleByIdImmutable = (id: string, config?: SWRConfiguration<RoleDTO>) => {
    return swrs.useGetRoleByIdImmutable(
      (id: string) => this.getRoleByIdRequestOpts({ id: id }),
      (context: runtime.RequestOpts) => this.swrFetch(this.getRoleByIdFetch(context)),
      id,
      config,
    )
  }

  /**
   * Get role details by ID (with permissions)
   * Get role by ID
   */
  useGetRoleByIdMutation = (id: string, config?: SWRMutationConfiguration<RoleDTO, any, string, never, RoleDTO>) => {
    return swrs.useGetRoleByIdMutation(
      (id: string) => this.getRoleByIdRequestOpts({ id: id }),
      (context: runtime.RequestOpts) => this.swrFetch(this.getRoleByIdFetch(context)),
      id,
      config,
    )
  }

  /**
   * Get user details by ID (with roles)
   * Get user by ID
   */
  protected getUserByIdRequestOpts = (requestParameters: GetUserByIdRequest): runtime.RequestOpts => {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling getUserById.",
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    return {
      path: `/api/admin/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }
  }

  /**
   * Get user details by ID (with roles)
   * Get user by ID
   */
  protected getUserByIdFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UserDTO>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.JSONApiResponse(response, (jsonValue) => UserDTOFromJSON(jsonValue))
  }

  /**
   * Get user details by ID (with roles)
   * Get user by ID
   */
  protected getUserByIdRaw = async (
    requestParameters: GetUserByIdRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UserDTO>> => {
    const context = this.getUserByIdRequestOpts(requestParameters)
    return this.getUserByIdFetch(context, initOverrides)
  }

  /**
   * Get user details by ID (with roles)
   * Get user by ID
   */
  getUserById = async (id: string, initOverrides?: RequestInit): Promise<UserDTO> => {
    const response = await this.getUserByIdRaw({ id: id }, initOverrides)
    return await response.value()
  }

  /**
   * Get user details by ID (with roles)
   * Get user by ID
   */
  useGetUserById = (id: string, config?: SWRConfiguration<UserDTO>) => {
    return swrs.useGetUserById(
      (id: string) => this.getUserByIdRequestOpts({ id: id }),
      (context: runtime.RequestOpts) => this.swrFetch(this.getUserByIdFetch(context)),
      id,
      config,
    )
  }

  /**
   * Get user details by ID (with roles)
   * Get user by ID
   */
  useGetUserByIdImmutable = (id: string, config?: SWRConfiguration<UserDTO>) => {
    return swrs.useGetUserByIdImmutable(
      (id: string) => this.getUserByIdRequestOpts({ id: id }),
      (context: runtime.RequestOpts) => this.swrFetch(this.getUserByIdFetch(context)),
      id,
      config,
    )
  }

  /**
   * Get user details by ID (with roles)
   * Get user by ID
   */
  useGetUserByIdMutation = (id: string, config?: SWRMutationConfiguration<UserDTO, any, string, never, UserDTO>) => {
    return swrs.useGetUserByIdMutation(
      (id: string) => this.getUserByIdRequestOpts({ id: id }),
      (context: runtime.RequestOpts) => this.swrFetch(this.getUserByIdFetch(context)),
      id,
      config,
    )
  }

  /**
   * Get final computed permissions for specific user
   * Get user permissions
   */
  protected getUserPermissionsRequestOpts = (requestParameters: GetUserPermissionsRequest): runtime.RequestOpts => {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling getUserPermissions.",
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    return {
      path: `/api/admin/users/{id}/permissions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }
  }

  /**
   * Get final computed permissions for specific user
   * Get user permissions
   */
  protected getUserPermissionsFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Get final computed permissions for specific user
   * Get user permissions
   */
  protected getUserPermissionsRaw = async (
    requestParameters: GetUserPermissionsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> => {
    const context = this.getUserPermissionsRequestOpts(requestParameters)
    return this.getUserPermissionsFetch(context, initOverrides)
  }

  /**
   * Get final computed permissions for specific user
   * Get user permissions
   */
  getUserPermissions = async (id: string, initOverrides?: RequestInit): Promise<void> => {
    await this.getUserPermissionsRaw({ id: id }, initOverrides)
  }

  /**
   * Get final computed permissions for specific user
   * Get user permissions
   */
  useGetUserPermissions = (id: string, config?: SWRConfiguration<void>) => {
    return swrs.useGetUserPermissions(
      (id: string) => this.getUserPermissionsRequestOpts({ id: id }),
      (context: runtime.RequestOpts) => this.swrFetch(this.getUserPermissionsFetch(context)),
      id,
      config,
    )
  }

  /**
   * Get final computed permissions for specific user
   * Get user permissions
   */
  useGetUserPermissionsImmutable = (id: string, config?: SWRConfiguration<void>) => {
    return swrs.useGetUserPermissionsImmutable(
      (id: string) => this.getUserPermissionsRequestOpts({ id: id }),
      (context: runtime.RequestOpts) => this.swrFetch(this.getUserPermissionsFetch(context)),
      id,
      config,
    )
  }

  /**
   * Get final computed permissions for specific user
   * Get user permissions
   */
  useGetUserPermissionsMutation = (id: string, config?: SWRMutationConfiguration<void, any, string, never, void>) => {
    return swrs.useGetUserPermissionsMutation(
      (id: string) => this.getUserPermissionsRequestOpts({ id: id }),
      (context: runtime.RequestOpts) => this.swrFetch(this.getUserPermissionsFetch(context)),
      id,
      config,
    )
  }

  /**
   * Search users by username, email, firstName or lastName (case-insensitive)
   * Search users
   */
  protected searchUsersRequestOpts = (requestParameters: SearchUsersRequest): runtime.RequestOpts => {
    if (requestParameters.pageable === null || requestParameters.pageable === undefined) {
      throw new runtime.RequiredError(
        "pageable",
        "Required parameter requestParameters.pageable was null or undefined when calling searchUsers.",
      )
    }

    const queryParameters: any = {}

    if (requestParameters.q !== undefined) {
      queryParameters["q"] = requestParameters.q
    }

    if (requestParameters.pageable !== undefined) {
      queryParameters["pageable"] = requestParameters.pageable
    }

    const headerParameters: runtime.HTTPHeaders = {}

    return {
      path: `/api/admin/users/search`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }
  }

  /**
   * Search users by username, email, firstName or lastName (case-insensitive)
   * Search users
   */
  protected searchUsersFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Page>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.JSONApiResponse(response, (jsonValue) => PageFromJSON(jsonValue))
  }

  /**
   * Search users by username, email, firstName or lastName (case-insensitive)
   * Search users
   */
  protected searchUsersRaw = async (
    requestParameters: SearchUsersRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Page>> => {
    const context = this.searchUsersRequestOpts(requestParameters)
    return this.searchUsersFetch(context, initOverrides)
  }

  /**
   * Search users by username, email, firstName or lastName (case-insensitive)
   * Search users
   */
  searchUsers = async (pageable: Pageable, q?: string, initOverrides?: RequestInit): Promise<Page> => {
    const response = await this.searchUsersRaw({ pageable: pageable, q: q }, initOverrides)
    return await response.value()
  }

  /**
   * Search users by username, email, firstName or lastName (case-insensitive)
   * Search users
   */
  useSearchUsers = (pageable: Pageable, q?: string, config?: SWRConfiguration<Page>) => {
    return swrs.useSearchUsers(
      (pageable: Pageable, q?: string) => this.searchUsersRequestOpts({ pageable: pageable, q: q }),
      (context: runtime.RequestOpts) => this.swrFetch(this.searchUsersFetch(context)),
      pageable,
      q,
      config,
    )
  }

  /**
   * Search users by username, email, firstName or lastName (case-insensitive)
   * Search users
   */
  useSearchUsersImmutable = (pageable: Pageable, q?: string, config?: SWRConfiguration<Page>) => {
    return swrs.useSearchUsersImmutable(
      (pageable: Pageable, q?: string) => this.searchUsersRequestOpts({ pageable: pageable, q: q }),
      (context: runtime.RequestOpts) => this.swrFetch(this.searchUsersFetch(context)),
      pageable,
      q,
      config,
    )
  }

  /**
   * Search users by username, email, firstName or lastName (case-insensitive)
   * Search users
   */
  useSearchUsersMutation = (
    pageable: Pageable,
    q?: string,
    config?: SWRMutationConfiguration<Page, any, string, never, Page>,
  ) => {
    return swrs.useSearchUsersMutation(
      (pageable: Pageable, q?: string) => this.searchUsersRequestOpts({ pageable: pageable, q: q }),
      (context: runtime.RequestOpts) => this.swrFetch(this.searchUsersFetch(context)),
      pageable,
      q,
      config,
    )
  }

  /**
   * Lock or unlock user account
   * Toggle user lock
   */
  protected toggleUserLockRequestOpts = (requestParameters: ToggleUserLockRequest): runtime.RequestOpts => {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling toggleUserLock.",
      )
    }

    if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
      throw new runtime.RequiredError(
        "requestBody",
        "Required parameter requestParameters.requestBody was null or undefined when calling toggleUserLock.",
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    return {
      path: `/api/admin/users/{id}/lock`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.requestBody,
    }
  }

  /**
   * Lock or unlock user account
   * Toggle user lock
   */
  protected toggleUserLockFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UserDTO>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.JSONApiResponse(response, (jsonValue) => UserDTOFromJSON(jsonValue))
  }

  /**
   * Lock or unlock user account
   * Toggle user lock
   */
  protected toggleUserLockRaw = async (
    requestParameters: ToggleUserLockRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UserDTO>> => {
    const context = this.toggleUserLockRequestOpts(requestParameters)
    return this.toggleUserLockFetch(context, initOverrides)
  }

  /**
   * Lock or unlock user account
   * Toggle user lock
   */
  toggleUserLock = async (
    id: string,
    requestBody: { [key: string]: boolean },
    initOverrides?: RequestInit,
  ): Promise<UserDTO> => {
    const response = await this.toggleUserLockRaw({ id: id, requestBody: requestBody }, initOverrides)
    return await response.value()
  }

  /**
   * Lock or unlock user account
   * Toggle user lock
   */
  useToggleUserLock = (id: string, requestBody: { [key: string]: boolean }, config?: SWRConfiguration<UserDTO>) => {
    return swrs.useToggleUserLock(
      (id: string, requestBody: { [key: string]: boolean }) =>
        this.toggleUserLockRequestOpts({ id: id, requestBody: requestBody }),
      (context: runtime.RequestOpts) => this.swrFetch(this.toggleUserLockFetch(context)),
      id,
      requestBody,
      config,
    )
  }

  /**
   * Lock or unlock user account
   * Toggle user lock
   */
  useToggleUserLockImmutable = (
    id: string,
    requestBody: { [key: string]: boolean },
    config?: SWRConfiguration<UserDTO>,
  ) => {
    return swrs.useToggleUserLockImmutable(
      (id: string, requestBody: { [key: string]: boolean }) =>
        this.toggleUserLockRequestOpts({ id: id, requestBody: requestBody }),
      (context: runtime.RequestOpts) => this.swrFetch(this.toggleUserLockFetch(context)),
      id,
      requestBody,
      config,
    )
  }

  /**
   * Lock or unlock user account
   * Toggle user lock
   */
  useToggleUserLockMutation = (
    id: string,
    requestBody: { [key: string]: boolean },
    config?: SWRMutationConfiguration<UserDTO, any, string, never, UserDTO>,
  ) => {
    return swrs.useToggleUserLockMutation(
      (id: string, requestBody: { [key: string]: boolean }) =>
        this.toggleUserLockRequestOpts({ id: id, requestBody: requestBody }),
      (context: runtime.RequestOpts) => this.swrFetch(this.toggleUserLockFetch(context)),
      id,
      requestBody,
      config,
    )
  }

  /**
   * Enable or disable user account
   * Toggle user status
   */
  protected toggleUserStatusRequestOpts = (requestParameters: ToggleUserStatusRequest): runtime.RequestOpts => {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling toggleUserStatus.",
      )
    }

    if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
      throw new runtime.RequiredError(
        "requestBody",
        "Required parameter requestParameters.requestBody was null or undefined when calling toggleUserStatus.",
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    return {
      path: `/api/admin/users/{id}/status`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.requestBody,
    }
  }

  /**
   * Enable or disable user account
   * Toggle user status
   */
  protected toggleUserStatusFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UserDTO>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.JSONApiResponse(response, (jsonValue) => UserDTOFromJSON(jsonValue))
  }

  /**
   * Enable or disable user account
   * Toggle user status
   */
  protected toggleUserStatusRaw = async (
    requestParameters: ToggleUserStatusRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UserDTO>> => {
    const context = this.toggleUserStatusRequestOpts(requestParameters)
    return this.toggleUserStatusFetch(context, initOverrides)
  }

  /**
   * Enable or disable user account
   * Toggle user status
   */
  toggleUserStatus = async (
    id: string,
    requestBody: { [key: string]: boolean },
    initOverrides?: RequestInit,
  ): Promise<UserDTO> => {
    const response = await this.toggleUserStatusRaw({ id: id, requestBody: requestBody }, initOverrides)
    return await response.value()
  }

  /**
   * Enable or disable user account
   * Toggle user status
   */
  useToggleUserStatus = (id: string, requestBody: { [key: string]: boolean }, config?: SWRConfiguration<UserDTO>) => {
    return swrs.useToggleUserStatus(
      (id: string, requestBody: { [key: string]: boolean }) =>
        this.toggleUserStatusRequestOpts({ id: id, requestBody: requestBody }),
      (context: runtime.RequestOpts) => this.swrFetch(this.toggleUserStatusFetch(context)),
      id,
      requestBody,
      config,
    )
  }

  /**
   * Enable or disable user account
   * Toggle user status
   */
  useToggleUserStatusImmutable = (
    id: string,
    requestBody: { [key: string]: boolean },
    config?: SWRConfiguration<UserDTO>,
  ) => {
    return swrs.useToggleUserStatusImmutable(
      (id: string, requestBody: { [key: string]: boolean }) =>
        this.toggleUserStatusRequestOpts({ id: id, requestBody: requestBody }),
      (context: runtime.RequestOpts) => this.swrFetch(this.toggleUserStatusFetch(context)),
      id,
      requestBody,
      config,
    )
  }

  /**
   * Enable or disable user account
   * Toggle user status
   */
  useToggleUserStatusMutation = (
    id: string,
    requestBody: { [key: string]: boolean },
    config?: SWRMutationConfiguration<UserDTO, any, string, never, UserDTO>,
  ) => {
    return swrs.useToggleUserStatusMutation(
      (id: string, requestBody: { [key: string]: boolean }) =>
        this.toggleUserStatusRequestOpts({ id: id, requestBody: requestBody }),
      (context: runtime.RequestOpts) => this.swrFetch(this.toggleUserStatusFetch(context)),
      id,
      requestBody,
      config,
    )
  }

  /**
   * Update existing user (partial update)
   * Update user
   */
  protected updateUserRequestOpts = (requestParameters: UpdateUserOperationRequest): runtime.RequestOpts => {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling updateUser.",
      )
    }

    if (requestParameters.updateUserRequest === null || requestParameters.updateUserRequest === undefined) {
      throw new runtime.RequiredError(
        "updateUserRequest",
        "Required parameter requestParameters.updateUserRequest was null or undefined when calling updateUser.",
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    return {
      path: `/api/admin/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateUserRequestToJSON(requestParameters.updateUserRequest),
    }
  }

  /**
   * Update existing user (partial update)
   * Update user
   */
  protected updateUserFetch = async (
    context: runtime.RequestOpts,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UserDTO>> => {
    const response = await this.request(context, initOverrides)

    return new runtime.JSONApiResponse(response, (jsonValue) => UserDTOFromJSON(jsonValue))
  }

  /**
   * Update existing user (partial update)
   * Update user
   */
  protected updateUserRaw = async (
    requestParameters: UpdateUserOperationRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UserDTO>> => {
    const context = this.updateUserRequestOpts(requestParameters)
    return this.updateUserFetch(context, initOverrides)
  }

  /**
   * Update existing user (partial update)
   * Update user
   */
  updateUser = async (
    id: string,
    updateUserRequest: UpdateUserRequest,
    initOverrides?: RequestInit,
  ): Promise<UserDTO> => {
    const response = await this.updateUserRaw({ id: id, updateUserRequest: updateUserRequest }, initOverrides)
    return await response.value()
  }

  /**
   * Update existing user (partial update)
   * Update user
   */
  useUpdateUser = (id: string, updateUserRequest: UpdateUserRequest, config?: SWRConfiguration<UserDTO>) => {
    return swrs.useUpdateUser(
      (id: string, updateUserRequest: UpdateUserRequest) =>
        this.updateUserRequestOpts({ id: id, updateUserRequest: updateUserRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.updateUserFetch(context)),
      id,
      updateUserRequest,
      config,
    )
  }

  /**
   * Update existing user (partial update)
   * Update user
   */
  useUpdateUserImmutable = (id: string, updateUserRequest: UpdateUserRequest, config?: SWRConfiguration<UserDTO>) => {
    return swrs.useUpdateUserImmutable(
      (id: string, updateUserRequest: UpdateUserRequest) =>
        this.updateUserRequestOpts({ id: id, updateUserRequest: updateUserRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.updateUserFetch(context)),
      id,
      updateUserRequest,
      config,
    )
  }

  /**
   * Update existing user (partial update)
   * Update user
   */
  useUpdateUserMutation = (
    id: string,
    updateUserRequest: UpdateUserRequest,
    config?: SWRMutationConfiguration<UserDTO, any, string, never, UserDTO>,
  ) => {
    return swrs.useUpdateUserMutation(
      (id: string, updateUserRequest: UpdateUserRequest) =>
        this.updateUserRequestOpts({ id: id, updateUserRequest: updateUserRequest }),
      (context: runtime.RequestOpts) => this.swrFetch(this.updateUserFetch(context)),
      id,
      updateUserRequest,
      config,
    )
  }
}
