/* tslint:disable */
/* eslint-disable */
/**
 * RAISER - Warehouse Management System API
 * REST API Ð´Ð»Ñ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹ ÑÐºÐ»Ð°Ð´ÑÐºÐ¾Ð³Ð¾ ÑƒÑ‡Ñ‘Ñ‚Ð° RAISER.  ## ÐÑƒÑ‚ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ñ  API Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚ Ð´Ð²Ð° Ð¼ÐµÑ‚Ð¾Ð´Ð° Ð°ÑƒÑ‚ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ð¸:  ### ðŸ” ÐœÐµÑ‚Ð¾Ð´ 1: JWT Bearer Token (Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÑ‚ÑÑ) 1. POST /api/auth/login - Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ access token Ð¸ refresh token 2. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ access token Ð´Ð»Ñ Ð²ÑÐµÑ… Ð·Ð°Ñ‰Ð¸Ñ‰Ñ‘Ð½Ð½Ñ‹Ñ… endpoints 3. POST /api/auth/refresh - Ð¾Ð±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ access token (ÐºÐ¾Ð³Ð´Ð° Ð¸ÑÑ‚ÐµÑ‡Ñ‘Ñ‚)  **ÐŸÑ€ÐµÐ¸Ð¼ÑƒÑ‰ÐµÑÑ‚Ð²Ð°:** - âœ… Stateless (Ð½Ðµ Ð½ÑƒÐ¶Ð½Ð° session Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€Ðµ) - âœ… Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð´Ð»Ñ production - âœ… ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° refresh tokens - âœ… ÐœÐ°ÑÑˆÑ‚Ð°Ð±Ð¸Ñ€ÑƒÐµÑ‚ÑÑ Ð³Ð¾Ñ€Ð¸Ð·Ð¾Ð½Ñ‚Ð°Ð»ÑŒÐ½Ð¾  ### ðŸ”“ ÐœÐµÑ‚Ð¾Ð´ 2: HTTP Basic Authentication (Ñ‚Ð¾Ð»ÑŒÐºÐ¾ dev/staging!) ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐ¹Ñ‚Ðµ username Ð¸ password Ð² ÐºÐ°Ð¶Ð´Ð¾Ð¼ request.  **Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð´Ð»Ñ:** - âœ… Ð‘Ñ‹ÑÑ‚Ñ€Ð¾Ð³Ð¾ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð² Swagger UI - âœ… Dev/Staging Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ð¹ - âŒ ÐÐ• Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð² production Ð±ÐµÐ· HTTPS!  ### ÐÐ²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ñ (Permission-based RBAC) Ð¡Ð¸ÑÑ‚ÐµÐ¼Ð° Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ Ð¿Ñ€Ð°Ð²Ð° Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð° (permissions): - Permissions (Ð¿Ñ€Ð°Ð²Ð°): USER_VIEW, USER_CREATE, USER_EDIT, INVENTORY_WRITE, etc. - Roles (Ñ€Ð¾Ð»Ð¸): ADMIN, WR_KEEPER, USER - User-level overrides: permissionsAdd, permissionsRemove - Ð¤Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð¿Ñ€Ð°Ð²Ð°: (role_permissions âˆª permissionsAdd) âˆ’ permissionsRemove  ## Ð¢Ð¸Ð¿Ð¸Ñ‡Ð½Ñ‹Ð¹ workflow:  **Ð¡ JWT:** 1. POST /api/auth/login â†’ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ accessToken 2. ÐÐ°Ð¶Ð°Ñ‚ÑŒ \"Authorize\" â†’ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ \"Bearer Authentication\" 3. Ð’ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ Ñ‚Ð¾ÐºÐµÐ½ â†’ Authorize 4. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ API endpoints  **Ð¡ Basic Auth (Ñ‚Ð¾Ð»ÑŒÐºÐ¾ dev/staging):** 1. ÐÐ°Ð¶Ð°Ñ‚ÑŒ \"Authorize\" â†’ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ \"Basic Authentication\" 2. Ð’Ð²ÐµÑÑ‚Ð¸ username Ð¸ password â†’ Authorize 3. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ API endpoints (credentials Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÑŽÑ‚ÑÑ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: dev@raiser.uz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

export const BASE_PATH = "http://57.128.245.65:8090".replace(/\/+$/, "")

const isBlob = (value: any) => typeof Blob !== "undefined" && value instanceof Blob

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {
  private middleware: Middleware[]

  constructor(protected configuration = new Configuration()) {
    this.middleware = configuration.middleware
  }

  withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
    const next = this.clone<T>()
    next.middleware = next.middleware.concat(...middlewares)
    return next
  }

  withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware["pre"]>) {
    const middlewares = preMiddlewares.map((pre) => ({ pre }))
    return this.withMiddleware<T>(...middlewares)
  }

  withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware["post"]>) {
    const middlewares = postMiddlewares.map((post) => ({ post }))
    return this.withMiddleware<T>(...middlewares)
  }

  protected async request(context: RequestOpts, initOverrides?: RequestInit): Promise<Response> {
    const { url, init } = this.createFetchParams(context, initOverrides)
    const response = await this.fetchApi(url, init)
    if (response.status >= 200 && response.status < 300) {
      return response
    }
    throw new ApiError(url, init, response)
  }

  protected async swrFetch<T extends any>(data: Promise<ApiResponse<T>>): Promise<T> {
    try {
      return (await data).value()
    } catch (resp) {
      if (resp instanceof ApiError) {
        throw await resp.response.json()
      } else {
        throw resp
      }
    }
  }

  private createFetchParams(context: RequestOpts, initOverrides?: RequestInit) {
    let url = this.configuration.basePath + context.path
    if (context.query !== undefined && Object.keys(context.query).length !== 0) {
      // only add the querystring to the URL if there are query parameters.
      // this is done to avoid urls ending with a "?" character which buggy webservers
      // do not handle correctly sometimes.
      url += "?" + this.configuration.queryParamsStringify(context.query)
    }
    const body =
      (typeof FormData !== "undefined" && context.body instanceof FormData) ||
      context.body instanceof URLSearchParams ||
      isBlob(context.body)
        ? context.body
        : JSON.stringify(context.body)

    const headers = Object.assign({}, this.configuration.headers, context.headers)
    const init = {
      method: context.method,
      headers: headers,
      body,
      credentials: this.configuration.credentials,
      ...initOverrides,
    }
    return { url, init }
  }

  private fetchApi = async (url: string, init: RequestInit) => {
    let fetchParams = { url, init }
    for (const middleware of this.middleware) {
      if (middleware.pre) {
        fetchParams =
          (await middleware.pre({
            fetch: this.fetchApi,
            ...fetchParams,
          })) || fetchParams
      }
    }
    let response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init)
    for (const middleware of this.middleware) {
      if (middleware.post) {
        response =
          (await middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone(),
          })) || response
      }
    }
    return response
  }

  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  private clone<T extends BaseAPI>(this: T): T {
    const constructor = this.constructor as any
    const next = new constructor(this.configuration)
    next.middleware = this.middleware.slice()
    return next
  }
}

export class RequiredError extends Error {
  name: "RequiredError" = "RequiredError"
  constructor(
    public field: string,
    msg?: string,
  ) {
    super(msg)
  }
}

export class ApiError extends Error {
  name: "ApiError" = "ApiError"
  constructor(
    readonly url: string,
    readonly request: RequestInit,
    readonly response: Response,
  ) {
    super(`${response.status} ${response.statusText}`)
  }
}

export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|",
}

export type FetchAPI = WindowOrWorkerGlobalScope["fetch"]

export interface ConfigurationParameters {
  basePath?: string // override base path
  fetchApi?: FetchAPI // override for fetch implementation
  middleware?: Middleware[] // middleware to apply before/after fetch requests
  queryParamsStringify?: (params: HTTPQuery) => string // stringify function for query strings
  username?: string // parameter for basic security
  password?: string // parameter for basic security
  apiKey?: string | ((name: string) => string) // parameter for apiKey security
  accessToken?: string | ((name?: string, scopes?: string[]) => string) // parameter for oauth2 security
  headers?: HTTPHeaders //header params we want to use on every request
  credentials?: RequestCredentials //value for the credentials param we want to use on each request
}

export class Configuration {
  constructor(private configuration: ConfigurationParameters = {}) {}

  get basePath(): string {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH
  }

  get fetchApi(): FetchAPI | undefined {
    return this.configuration.fetchApi
  }

  get middleware(): Middleware[] {
    return this.configuration.middleware || []
  }

  get queryParamsStringify(): (params: HTTPQuery) => string {
    return this.configuration.queryParamsStringify || querystring
  }

  get username(): string | undefined {
    return this.configuration.username
  }

  get password(): string | undefined {
    return this.configuration.password
  }

  get apiKey(): ((name: string) => string) | undefined {
    const apiKey = this.configuration.apiKey
    if (apiKey) {
      return typeof apiKey === "function" ? apiKey : () => apiKey
    }
    return undefined
  }

  get accessToken(): ((name?: string, scopes?: string[]) => string) | undefined {
    const accessToken = this.configuration.accessToken
    if (accessToken) {
      return typeof accessToken === "function" ? accessToken : () => accessToken
    }
    return undefined
  }

  get headers(): HTTPHeaders | undefined {
    return this.configuration.headers
  }

  get credentials(): RequestCredentials | undefined {
    return this.configuration.credentials
  }
}

export type Json = any
export type HTTPMethod = "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "OPTIONS" | "HEAD"
export type HTTPHeaders = { [key: string]: string }
export type HTTPQuery = {
  [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | HTTPQuery
}
export type HTTPBody = Json | FormData | URLSearchParams
export type ModelPropertyNaming = "camelCase" | "snake_case" | "PascalCase" | "original"

export interface FetchParams {
  url: string
  init: RequestInit
}

export interface RequestOpts {
  path: string
  method: HTTPMethod
  headers: HTTPHeaders
  query?: HTTPQuery
  body?: HTTPBody
}

export function exists(json: any, key: string) {
  const value = json[key]
  return value !== null && value !== undefined
}

export function querystring(params: HTTPQuery, prefix: string = ""): string {
  return Object.keys(params)
    .map((key) => {
      const fullKey = prefix + (prefix.length ? `[${key}]` : key)
      const value = params[key]
      if (value instanceof Array) {
        const multiValue = value
          .map((singleValue) => encodeURIComponent(String(singleValue)))
          .join(`&${encodeURIComponent(fullKey)}=`)
        return `${encodeURIComponent(fullKey)}=${multiValue}`
      }
      if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`
      }
      if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey)
      }
      return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`
    })
    .filter((part) => part.length > 0)
    .join("&")
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce((acc, key) => ({ ...acc, [key]: fn(data[key]) }), {})
}

export function canConsumeForm(consumes: Consume[]): boolean {
  for (const consume of consumes) {
    if ("multipart/form-data" === consume.contentType) {
      return true
    }
  }
  return false
}

export interface Consume {
  contentType: string
}

export interface RequestContext {
  fetch: FetchAPI
  url: string
  init: RequestInit
}

export interface ResponseContext {
  fetch: FetchAPI
  url: string
  init: RequestInit
  response: Response
}

export interface Middleware {
  pre?(context: RequestContext): Promise<FetchParams | void>
  post?(context: ResponseContext): Promise<Response | void>
}

export interface ApiResponse<T> {
  raw: Response
  value(): Promise<T>
}

export interface ResponseTransformer<T> {
  (json: any): T
}

export class JSONApiResponse<T> {
  constructor(
    public raw: Response,
    private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue,
  ) {}

  async value(): Promise<T> {
    return this.transformer(await this.raw.json())
  }
}

export class VoidApiResponse {
  constructor(public raw: Response) {}

  async value(): Promise<void> {
    return undefined
  }
}

export class BlobApiResponse {
  constructor(public raw: Response) {}

  async value(): Promise<Blob> {
    return await this.raw.blob()
  }
}

export class TextApiResponse {
  constructor(public raw: Response) {}

  async value(): Promise<string> {
    return await this.raw.text()
  }
}
